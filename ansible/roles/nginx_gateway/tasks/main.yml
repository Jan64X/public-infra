---
# =============================================================================
# NGINX GATEWAY - Containerised Reverse-Proxy with Cloudflare-only firewall
# =============================================================================
# Deploys the shared "vps-services" Podman network, installs Podman, runs
# Nginx via Quadlet, obtains wildcard TLS certs via DNS-01, and restricts
# HTTPS access to Cloudflare edge IPs only (ipset + UFW FORWARD rules).
# =============================================================================

# =============================================================================
# PREREQUISITES
# =============================================================================

- name: Install required packages
  ansible.builtin.apt:
    name:
      - curl
      - ipset
      - iptables
      - git
      - acl
      - ca-certificates
      - gnupg
    state: present
    update_cache: true
    cache_valid_time: 3600

# =============================================================================
# PODMAN INSTALLATION
# =============================================================================

- name: Install Podman
  ansible.builtin.apt:
    name:
      - podman
      - uidmap
      - slirp4netns
    state: present
    update_cache: true
  become: true

- name: Ensure Quadlet directory exists
  ansible.builtin.file:
    path: /etc/containers/systemd
    state: directory
    mode: '0755'
  become: true

# =============================================================================
# DIRECTORY STRUCTURE
# =============================================================================

- name: Create nginx-gateway directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - /opt/nginx-gateway
    - /opt/nginx-gateway/conf.d
    - /opt/nginx-gateway/ssl
    - /opt/nginx-gateway/logs
    - /opt/nginx-gateway/scripts

# =============================================================================
# PODMAN HOST ACCESS (allow containers → host for DNS, metrics, etc.)
# =============================================================================

- name: Allow traffic from Podman containers to host
  community.general.ufw:
    rule: allow
    from_ip: 10.88.0.0/14
    comment: Podman containers to host (DNS, node_exporter, etc.)
  notify: Reload ufw

# =============================================================================
# CLOUDFLARE-ONLY FIREWALL (ipset + UFW FORWARD rules)
# =============================================================================
# Podman port-forwarding goes through the FORWARD chain.  We add ipset-based
# rules to UFW's before.rules / before6.rules to restrict port 443 to
# Cloudflare IPs only.  A systemd timer refreshes the ipsets daily.

- name: Install ipset
  ansible.builtin.apt:
    name: ipset
    state: present
  become: true

- name: Deploy ipset-restore systemd service
  ansible.builtin.copy:
    dest: /etc/systemd/system/ipset-restore.service
    mode: '0644'
    content: |
      [Unit]
      Description=Restore ipsets from /etc/ipsets.conf
      Before=ufw.service
      DefaultDependencies=no
      ConditionPathExists=/etc/ipsets.conf

      [Service]
      Type=oneshot
      ExecStart=/bin/sh -c 'ipset restore -! < /etc/ipsets.conf'
      RemainAfterExit=yes

      [Install]
      WantedBy=multi-user.target
  become: true
  notify: Reload systemd

- name: Enable ipset-restore service
  ansible.builtin.systemd:
    name: ipset-restore.service
    enabled: true
    daemon_reload: true
  become: true

- name: Deploy Cloudflare ipset update script
  ansible.builtin.template:
    src: update-cloudflare-ipset.sh.j2
    dest: /opt/nginx-gateway/scripts/update-cloudflare-ipset.sh
    mode: '0755'

- name: Deploy systemd service for Cloudflare ipset
  ansible.builtin.copy:
    dest: /etc/systemd/system/update-cloudflare-ipset.service
    mode: '0644'
    content: |
      [Unit]
      Description=Update Cloudflare IP sets
      After=network-online.target
      Wants=network-online.target

      [Service]
      Type=oneshot
      ExecStart=/opt/nginx-gateway/scripts/update-cloudflare-ipset.sh

      [Install]
      WantedBy=multi-user.target

- name: Enable Cloudflare ipset update service
  ansible.builtin.systemd:
    name: update-cloudflare-ipset.service
    enabled: true
    daemon_reload: true

- name: Deploy systemd timer for daily Cloudflare ipset refresh
  ansible.builtin.copy:
    dest: /etc/systemd/system/update-cloudflare-ipset.timer
    mode: '0644'
    content: |
      [Unit]
      Description=Daily refresh of Cloudflare IP sets

      [Timer]
      OnCalendar=*-*-* 04:00:00
      RandomizedDelaySec=300
      Persistent=true

      [Install]
      WantedBy=timers.target

- name: Enable and start Cloudflare ipset timer
  ansible.builtin.systemd:
    name: update-cloudflare-ipset.timer
    state: started
    enabled: true
    daemon_reload: true

- name: Check if Cloudflare ipsets are loaded
  ansible.builtin.command:
    cmd: ipset list cloudflare_v4
  register: nginx_gateway_ipset_check
  changed_when: false
  failed_when: false

- name: Run Cloudflare ipset update (first run)
  ansible.builtin.command:
    cmd: /opt/nginx-gateway/scripts/update-cloudflare-ipset.sh
  when: nginx_gateway_ipset_check.rc != 0
  changed_when: true

# --- Cloudflare-only HTTPS via UFW FORWARD chain ---
# Podman port-forwarding uses iptables DNAT + FORWARD, so we restrict
# port 443 in UFW's before.rules FORWARD chain using Cloudflare ipsets.

- name: Deploy UFW before.rules for Cloudflare-only HTTPS (IPv4)
  ansible.builtin.blockinfile:
    path: /etc/ufw/before.rules
    marker: "# {mark} ANSIBLE MANAGED - Cloudflare FORWARD rules"
    insertbefore: '^COMMIT'
    block: |
      # Allow established/related forwarded traffic
      -A ufw-before-forward -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      # Allow all outbound traffic FROM Podman containers (e.g. SearXNG fetching search results)
      -A ufw-before-forward -s 10.88.0.0/14 -j ACCEPT
      # Allow Cloudflare IPs to port 443
      -A ufw-before-forward -p tcp --dport 443 -m set --match-set cloudflare_v4 src -j ACCEPT
      # Drop other inbound port 443
      -A ufw-before-forward -p tcp --dport 443 -j DROP
  notify: Reload ufw

- name: Deploy UFW before6.rules for Cloudflare-only HTTPS (IPv6)
  ansible.builtin.blockinfile:
    path: /etc/ufw/before6.rules
    marker: "# {mark} ANSIBLE MANAGED - Cloudflare FORWARD rules"
    insertbefore: '^COMMIT'
    block: |
      # Allow established/related forwarded traffic
      -A ufw6-before-forward -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      # Allow Cloudflare IPs to port 443
      -A ufw6-before-forward -p tcp --dport 443 -m set --match-set cloudflare_v6 src -j ACCEPT
      # Drop other inbound port 443
      -A ufw6-before-forward -p tcp --dport 443 -j DROP
  notify: Reload ufw

# --- Clean up stale Docker-era firewall artefacts ---

- name: Remove stale DOCKER-USER firewall script
  ansible.builtin.file:
    path: /opt/nginx-gateway/scripts/docker-user-firewall.sh
    state: absent

- name: Remove stale docker-user-firewall systemd service
  ansible.builtin.file:
    path: /etc/systemd/system/docker-user-firewall.service
    state: absent
  notify: Reload systemd

# =============================================================================
# CERTBOT (host-level — simpler than containerising DNS-01)
# =============================================================================

- name: Install Certbot and Cloudflare plugin
  ansible.builtin.apt:
    name:
      - certbot
      - python3-certbot-dns-cloudflare
    state: present

- name: Create Cloudflare API credentials file
  ansible.builtin.copy:
    dest: /etc/letsencrypt/cloudflare.ini
    mode: '0600'
    content: |
      dns_cloudflare_api_token = {{ cloudflare_api_token }}

- name: Generate wildcard certificate
  ansible.builtin.command:
    cmd: >
      certbot certonly --dns-cloudflare
      --dns-cloudflare-credentials /etc/letsencrypt/cloudflare.ini
      --dns-cloudflare-propagation-seconds 60
      --non-interactive --agree-tos --email {{ certbot_email }}
      --cert-name {{ base_domain }}
      -d {{ base_domain }} -d *.{{ base_domain }}
      --keep-until-expiring
  args:
    creates: "/etc/letsencrypt/live/{{ base_domain }}/fullchain.pem"

- name: Ensure renewal hooks directory exists
  ansible.builtin.file:
    path: /etc/letsencrypt/renewal-hooks/deploy
    state: directory
    mode: '0755'

- name: Add deploy hook to reload Nginx container on cert renewal
  ansible.builtin.copy:
    dest: /etc/letsencrypt/renewal-hooks/deploy/nginx_reload
    mode: '0755'
    content: |
      #!/bin/sh
      podman exec nginx-gateway nginx -s reload

- name: Ensure Certbot renewal timer is active
  ansible.builtin.service:
    name: certbot.timer
    state: started
    enabled: true

# =============================================================================
# NGINX CONFIGURATION
# =============================================================================

- name: Fetch Cloudflare IPv4 list (for set_real_ip_from)
  ansible.builtin.uri:
    url: https://www.cloudflare.com/ips-v4
    return_content: true
  register: nginx_gateway_cf_ipv4

- name: Fetch Cloudflare IPv6 list (for set_real_ip_from)
  ansible.builtin.uri:
    url: https://www.cloudflare.com/ips-v6
    return_content: true
  register: nginx_gateway_cf_ipv6

- name: Generate dhparams
  community.crypto.openssl_dhparam:
    path: /opt/nginx-gateway/ssl/dhparam.pem
    size: 2048

- name: Deploy main nginx.conf
  ansible.builtin.template:
    src: nginx.conf.j2
    dest: /opt/nginx-gateway/nginx.conf
    mode: '0644'
  notify: Restart nginx-gateway

- name: Deploy virtual host configs
  ansible.builtin.template:
    src: "{{ item }}.conf.j2"
    dest: "/opt/nginx-gateway/conf.d/{{ item }}.conf"
    mode: '0644'
  loop: "{{ nginx_vhosts }}"
  notify: Restart nginx-gateway

# =============================================================================
# STATIC WEBSITE
# =============================================================================

- name: Ensure static website directory exists
  ansible.builtin.file:
    path: "{{ static_website.local_path }}"
    state: directory
    mode: '0755'
    owner: root
    group: root
  when: static_website.enabled | default(false)

- name: Deploy static site from Git
  ansible.builtin.git:
    repo: "{{ static_website.repo_url }}"
    dest: "{{ static_website.local_path }}"
    version: "{{ static_website.repo_branch }}"
    force: true
    depth: 1
  when: static_website.enabled | default(false)

- name: Enforce secure permissions on static site
  ansible.builtin.file:
    path: "{{ static_website.local_path }}"
    state: directory
    recurse: true
    owner: root
    group: root
    mode: u=rwX,g=rX,o=rX
  when: static_website.enabled | default(false)

# =============================================================================
# PODMAN QUADLET
# =============================================================================

- name: Deploy vps-services network Quadlet
  ansible.builtin.template:
    src: vps-services.network.j2
    dest: /etc/containers/systemd/vps-services.network
    mode: '0644'
  notify: Reload systemd

- name: Deploy nginx-gateway container Quadlet
  ansible.builtin.template:
    src: nginx-gateway.container.j2
    dest: /etc/containers/systemd/nginx-gateway.container
    mode: '0644'
  notify: Restart nginx-gateway

- name: Reload systemd to pick up Quadlet units
  ansible.builtin.systemd:
    daemon_reload: true
  become: true

- name: Check if nginx-gateway image exists locally
  ansible.builtin.command:
    cmd: podman image exists docker.io/library/nginx:stable-alpine
  register: nginx_gateway_image_check
  changed_when: false
  failed_when: false
  become: true

- name: Pull nginx-gateway image
  ansible.builtin.command:
    cmd: podman pull docker.io/library/nginx:stable-alpine
  when: nginx_gateway_image_check.rc != 0
  changed_when: true
  become: true

- name: Start nginx-gateway service
  ansible.builtin.systemd:
    name: nginx-gateway
    state: started
    enabled: true
  become: true

# --- Clean up stale Docker-era artefacts ---

- name: Remove stale docker-compose.yml
  ansible.builtin.file:
    path: /opt/nginx-gateway/docker-compose.yml
    state: absent
